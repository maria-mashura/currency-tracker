<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Currency Tracker</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        table { border-collapse: collapse; width: 90%; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        th { background-color: #f2f2f2; position: relative; cursor: pointer; user-select: none; }
        th::after { content: " ▲"; font-size: 10px; position: absolute; right: 8px; opacity: 0.25; }
        th.asc::after { content: " ▲"; opacity: 1; color: green; }
        th.desc::after { content: " ▼"; opacity: 1; color: red; }
        .best-buy { background-color: #c8e6c9; }
        .best-sell { background-color: #ffcdd2; }
        h2 { margin-top: 40px; }
        select { font-size: 16px; margin: 0 10px 20px 0; }
        tbody tr:hover { background:#fafafa; }
    </style>
</head>
<body>
<h1>Currency Tracker</h1>

<label for="currencyFilter">Filter by currency:</label>
<select id="currencyFilter" onchange="onFilterChange()">
    <option value="ALL">All</option>
    <option value="USD">USD</option>
    <option value="EUR">EUR</option>
</select>

<label for="bankFilter">Filter by bank:</label>
<select id="bankFilter" onchange="onFilterChange()">
    <option value="ALL">All</option>
</select>

<h2>Current Rates (UAH Base)</h2>
<table id="currentRates">
    <thead>
        <tr>
            <th data-key="bank" onclick="sortTable('currentRates', ['bank','currency'])">Bank</th>
            <th data-key="currency" onclick="sortTable('currentRates', ['currency','bank'])">Currency</th>
            <th data-key="buy" onclick="sortTable('currentRates', ['buy'])">Buy (UAH/unit)</th>
            <th data-key="sell" onclick="sortTable('currentRates', ['sell'])">Sell (UAH/unit)</th>
            <th data-key="date" onclick="sortTable('currentRates', ['date'])">Date</th>
        </tr>
    </thead>
    <tbody></tbody>
</table>

<h2>Historical Rates</h2>
<table id="historicalRates">
    <thead>
        <tr>
            <th data-key="bank" onclick="sortTable('historicalRates', ['bank','currency'])">Bank</th>
            <th data-key="currency" onclick="sortTable('historicalRates', ['currency','bank'])">Currency</th>
            <th data-key="buy" onclick="sortTable('historicalRates', ['buy'])">Buy (UAH/unit)</th>
            <th data-key="sell" onclick="sortTable('historicalRates', ['sell'])">Sell (UAH/unit)</th>
            <th data-key="date" onclick="sortTable('historicalRates', ['date'])">Date</th>
        </tr>
    </thead>
    <tbody></tbody>
</table>

<script>
let ratesData = [];
let bankOptionsInitialized = false;
let sortState = {}; // хранит направление сортировки по ключу (ключ = tableId + keys.join('-'))

// Обработчик фильтров — сохраняет выбранные значения и перерисовывает таблицы
function onFilterChange() {
    // не пересоздаём опции банка, просто отрисовываем таблицы по новым фильтрам
    displayTables();
}

async function loadRates() {
    try {
        const response = await fetch('http://127.0.0.1:8000/rates/latest');
        const data = await response.json();
        // убираем RUB
        ratesData = (data.rates || []).filter(r => (r.currency || "").trim().toUpperCase() !== "RUB");

        // Заполняем фильтр по банкам один раз (не перезаписывать, чтобы не сбрасывать выбор)
        if (!bankOptionsInitialized) {
            const bankSet = new Set(ratesData.map(r => r.bank).filter(Boolean));
            const bankSelect = document.getElementById('bankFilter');
            bankSet.forEach(bank => {
                const opt = document.createElement('option');
                opt.value = bank;
                opt.textContent = bank;
                bankSelect.appendChild(opt);
            });
            bankOptionsInitialized = true;
        }

        displayTables();
    } catch (err) {
        console.error('Error loading rates', err);
    }
}

function displayTables() {
    const currencyFilter = document.getElementById('currencyFilter').value;
    const bankFilter = document.getElementById('bankFilter').value;

    let filtered = ratesData;
    if (currencyFilter && currencyFilter !== "ALL") {
        filtered = filtered.filter(r => (r.currency||"").toUpperCase() === currencyFilter);
    }
    if (bankFilter && bankFilter !== "ALL") {
        filtered = filtered.filter(r => r.bank === bankFilter);
    }

    // --- Current Rates: берем последний для каждой пары bank+currency ---
    const latestMap = {};
    filtered.forEach(rate => {
        const b = rate.bank || "";
        const c = (rate.currency || "").toUpperCase();
        const key = `${b}__${c}`;
        // преобразуем дату к timestamp для сравнения
        const ts = parseDateToTs(rate.date);
        if (!latestMap[key] || ts > latestMap[key]._ts) {
            latestMap[key] = Object.assign({}, rate);
            latestMap[key]._ts = ts;
        }
    });

    const latestArray = Object.values(latestMap).map(r => {
        // удалим служебное поле _ts перед рендером, но оставим timestamp в data-атрибуте
        const copy = Object.assign({}, r);
        delete copy._ts;
        return copy;
    });

    // подсветка лучших курсов (по валюте)
    const bestBuy = {};
    const worstSell = {};
    latestArray.forEach(rate => {
        const cur = (rate.currency || "").toUpperCase();
        if (!bestBuy[cur] || rate.buy > bestBuy[cur]) bestBuy[cur] = rate.buy;
        if (!worstSell[cur] || rate.sell < worstSell[cur]) worstSell[cur] = rate.sell;
    });

    // Рендер current table
    const tbodyCurrent = document.querySelector('#currentRates tbody');
    tbodyCurrent.innerHTML = '';
    latestArray.forEach(rate => {
        const row = document.createElement('tr');

        // вычисляем timestamp для даты и безопасно форматируем числа
        const ts = parseDateToTs(rate.date);
        const buyVal = Number(rate.buy) || 0;
        const sellVal = Number(rate.sell) || 0;

        // data-* атрибуты нужны для сортировки
        row.setAttribute('data-bank', rate.bank || "");
        row.setAttribute('data-currency', (rate.currency||"").toUpperCase());
        row.setAttribute('data-buy', buyVal);
        row.setAttribute('data-sell', sellVal);
        row.setAttribute('data-date', ts);

        row.innerHTML = `
            <td>${escapeHtml(rate.bank || "")}</td>
            <td>${escapeHtml((rate.currency||"").toUpperCase())}</td>
            <td class="${buyVal === bestBuy[(rate.currency||"").toUpperCase()] ? 'best-buy' : ''}">${buyVal.toFixed(2)}</td>
            <td class="${sellVal === worstSell[(rate.currency||"").toUpperCase()] ? 'best-sell' : ''}">${sellVal.toFixed(2)}</td>
            <td>${escapeHtml(rate.date || "")}</td>
        `;
        tbodyCurrent.appendChild(row);
    });

    // Рендер historical table (вся история, отфильтровано)
    const tbodyHist = document.querySelector('#historicalRates tbody');
    tbodyHist.innerHTML = '';
    filtered.forEach(rate => {
        const row = document.createElement('tr');

        const ts = parseDateToTs(rate.date);
        const buyVal = Number(rate.buy) || 0;
        const sellVal = Number(rate.sell) || 0;

        row.setAttribute('data-bank', rate.bank || "");
        row.setAttribute('data-currency', (rate.currency||"").toUpperCase());
        row.setAttribute('data-buy', buyVal);
        row.setAttribute('data-sell', sellVal);
        row.setAttribute('data-date', ts);

        row.innerHTML = `
            <td>${escapeHtml(rate.bank || "")}</td>
            <td>${escapeHtml((rate.currency||"").toUpperCase())}</td>
            <td>${buyVal.toFixed(2)}</td>
            <td>${sellVal.toFixed(2)}</td>
            <td>${escapeHtml(rate.date || "")}</td>
        `;
        tbodyHist.appendChild(row);
    });

    // Если таблица уже была отсортирована ранее, можно применить ту же сортировку:
    // проверим sortState и применим последний state для каждой таблицы
    for (const key in sortState) {
        if (!sortState.hasOwnProperty(key)) continue;
        const [tableId, ...rest] = key.split('::');
        const keys = rest.join('::').split('|')[0].split(',');
        // применим сортировку с сохранённым направлением
        if (tableId && document.getElementById(tableId)) {
            applySortVisual(tableId, keys, sortState[key]); // визуально покажем стрелку
        }
    }
}

// helper: парсит строку даты в timestamp (ms). Поддерживает формат "YYYY-MM-DD HH:MM:SS"
function parseDateToTs(dateStr) {
    if (!dateStr) return 0;
    // заменим пробел между датой и временем на 'T' чтобы new Date работал корректно
    // также уберём лишние части
    try {
        // иногда сервер может вернуть "YYYY-MM-DD HH:MM:SS"
        let s = dateStr.trim();
        // если уже в ISO - вернуть Number
        if (s.includes('T')) {
            const t = Date.parse(s);
            return isNaN(t) ? 0 : t;
        }
        // заменить пробел на T
        s = s.replace(' ', 'T');
        const t = Date.parse(s);
        if (!isNaN(t)) return t;
        // как fallback — заменить пробелы и двоеточия, создать вручную
        // разделение
        const parts = dateStr.split(' ');
        if (parts.length >= 2) {
            const datePart = parts[0].split('-').map(Number);
            const timePart = parts[1].split(':').map(Number);
            if (datePart.length === 3 && timePart.length >= 2) {
                const dt = new Date(datePart[0], datePart[1]-1, datePart[2], timePart[0], timePart[1], timePart[2] || 0);
                return dt.getTime();
            }
        }
    } catch (e) {
        // ignore
    }
    return 0;
}

// Сортировка: keys — массив ключей, например ['bank','currency']
// записываем в sortState ключ вида "tableId::bank,currency" -> true/false (asc boolean)
function sortTable(tableId, keys) {
    const table = document.getElementById(tableId);
    const tbody = table.tBodies[0];
    const rows = Array.from(tbody.rows);

    if (rows.length === 0) return;

    const stateKey = `${tableId}::${keys.join(',')}`;
    const prev = sortState[stateKey];
    const asc = prev === undefined ? true : !prev;
    sortState[stateKey] = asc;

    rows.sort((a, b) => {
        for (const key of keys) {
            let valA = a.getAttribute(`data-${key}`);
            let valB = b.getAttribute(`data-${key}`);

            // если значения отсутствуют, считать их пустой строкой или 0
            if (valA === null || valA === undefined) valA = "";
            if (valB === null || valB === undefined) valB = "";

            // попробуем числовое сравнение (для buy/sell/date)
            const numA = Number(valA);
            const numB = Number(valB);
            const bothNumeric = !isNaN(numA) && !isNaN(numB);

            if (bothNumeric) {
                if (numA > numB) return asc ? 1 : -1;
                if (numA < numB) return asc ? -1 : 1;
            } else {
                // строковое сравнение (case-insensitive)
                const sA = String(valA).toLowerCase();
                const sB = String(valB).toLowerCase();
                if (sA > sB) return asc ? 1 : -1;
                if (sA < sB) return asc ? -1 : 1;
            }
            // если равны — переходим к следующему ключу
        }
        return 0;
    });

    // Обновляем визуальные стрелки: убираем у всех th, ставим на первый ключ
    table.querySelectorAll('th').forEach(th => th.classList.remove('asc','desc'));
    // Найдём колонку с data-key === keys[0]
    const headerCells = table.tHead.rows[0].cells;
    let setArrow = false;
    for (let i = 0; i < headerCells.length; i++) {
        const th = headerCells[i];
        const k = th.getAttribute('data-key');
        if (k === keys[0]) {
            th.classList.add(asc ? 'asc' : 'desc');
            setArrow = true;
            break;
        }
    }
    if (!setArrow) {
        // если не нашли по data-key, ставим стрелку на первый th
        headerCells[0].classList.add(asc ? 'asc' : 'desc');
    }

    // Применяем отсортированные ряды в tbody
    rows.forEach(r => tbody.appendChild(r));
}

// Вспомогательная функция: просто показывает стрелку (без изменения порядка) по сохранённому состоянию
function applySortVisual(tableId, keys, asc) {
    const table = document.getElementById(tableId);
    if (!table) return;
    table.querySelectorAll('th').forEach(th => th.classList.remove('asc','desc'));
    const headerCells = table.tHead.rows[0].cells;
    for (let i = 0; i < headerCells.length; i++) {
        const th = headerCells[i];
        const k = th.getAttribute('data-key');
        if (k === keys[0]) {
            th.classList.add(asc ? 'asc' : 'desc');
            break;
        }
    }
}

// Простая защита от XSS при вставке текста
function escapeHtml(text) {
    if (!text) return "";
    return text.replaceAll('&', '&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;');
}

// старт
loadRates();
setInterval(loadRates, 60 * 1000);
</script>
</body>
</html>
